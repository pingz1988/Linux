- [grep](#grep)  
 - [用法](#用法)   
- [sed](#sed)  
 - [简介](#简介)  
 - [用法](#用法)  
 - [高级命令](#高级命令)  
- [awk](#awk)  


# grep

## 用法

```shell
grep [option] pattern file
```

| option       | description                                            |
| ------------ | ------------------------------------------------------ |
| -A<显示行数> | 除了显示符合范本样式的那一列之外，并显示该行之后的内容 |
| -B<显示行数> | 除了显示符合样式的那一行之外，并显示该行之前的内容     |
| -C<显示行数> | 除了显示符合样式的那一行之外，并显示该行之前后的内容   |
| -c           | 统计匹配的行数                                         |
| **-e**       | 现多个选项间的逻辑 or 关系                             |
| **-E**       | 扩展的正则表达式                                       |
| -i           | 忽略字符大小写                                         |
| -n           | 显示匹配的行号                                         |
| **-v**       | 显示不被pattern 匹配到的行，相当于[^] 反向匹配         |
| -w           | 匹配整个单词                                           |

------



# sed

### 简介

​          sed 是一种流编辑器，它一次处理一**行**内容 。 主要用来自动编辑一个或多个文件, 简化对文件的反复操作 。注意，**sed无法操作空文件**。

​          模式空间： 处理时，把当前处理的行存储在临时缓冲区中，即放数据的地方；

​          保持空间：协助模式空间处理，相当于模式空间的缓存。

### 用法

```shell
sed [options] '[地址定界] command' file(s)
```

| options    | description                                                  |
| ---------- | ------------------------------------------------------------ |
| **-n**     | 不输出模式空间内容到屏幕，即不自动打印，只打印匹配到的行。如 sed -n '1p' a.txt # 取第一行内容（效果等同于head -n 1 a.txt） |
| **-e**     | 多点编辑，对每行处理时，可以有多个Script                     |
| **-f**     | 把Script写到文件当中，在执行sed时-f 指定文件路径，如果是多个Script，换行写 |
| **-r**     | 支持扩展的正则表达式                                         |
| **-i**     | 直接将处理的结果写入文件                                     |
| **-i.bak** | 在将处理的结果写入文件之前备份一份                           |

| 地址定界      | description                                           |
| ------------- | ----------------------------------------------------- |
| 不给地址      | 对全文进行处理                                        |
| 指定的行号n   | 处理指定的第n行                                       |
| /pattern/     | 被此处模式所能够匹配到的每一行                        |
| n1,n2         | 处理第n1行至第n2行                                    |
| /pat1/,/pat2/ | 处理匹配到的pat1处至匹配到的pat2处                    |
| n,/pat1/      | 处理第n1行至匹配到的pat1行，sed -n "2,/DD/p" demo.txt |
| **~**         | 步进，sed -n **'1~2p'** ：只打印奇数行                |

| command  | description                                                  |
| -------- | ------------------------------------------------------------ |
| **d**    | **删除**模式空间匹配的行，并立即启用下一轮循环。sed "2d" demo.txt #删除第2行。sed '/user/d' a.txt  # 删除文件中所有包含user的行 |
| **p**    | 打印当前模式空间内容，追加到默认输出之后                     |
| **a**    | 在指定行**后面追加**文本，支持使用\n实现多行追加。sed "2a123" demo \#在第2行后加123。再如，sed -i '$athis is b\n' a.txt # 用$表示文件尾时，须用单引号，双引号中的$用来取变量值 |
| **i**    | 在行**前面插入**文本，支持使用\n实现多行追加。sed "1i 123" demo.txt \#在第1行前加123 |
| **c**    | **替换**行为单行或多行文本，支持使用\n实现多行追加。sed "3c 123" demo #替换第3行内容为123 |
| w        | 保存模式匹配的行至指定文件，如 sed -n "3w/root/demo3" demo #保存第3行的内容到demo3文件中 |
| r        | 读取指定文件的文本至模式空间中匹配到的行后                   |
| =        | 为模式空间中的行打印行号                                     |
| **!**    | 模式空间中匹配行**取反**处理，如 sed -n '2!p' demo #打印除了第2行的内容 |
| **s///** | **查找替换**，支持使用其它分隔符，如：s@@@，s###， sed 's@[a-z]@\u&@g' demo #将全文的小写字母替换为大写字母。并可结合以下命令使用： |
|          | **加g表示全局替换**，如 sed -i "s/a/A/g" demo.txt （-i编辑文件，替换所有的a成A，不加-i替换结果不会写入文件）; sed -i "1~2s/[aA]/E/g" demo.txt #将奇数行的a或A替换为E |
|          | \l：把下个字符转换成小写                                     |
|          | \L：把replacement字母转换成小写，直到\U或\E出现              |
|          | \u：把下个字符转换成大写                                     |
|          | \U：把replacement字母转换成大写，直到\L或\E出现              |
|          | \E：停止以\L或\U开始的大小写转换                             |

### 高级命令

| h    | 把模式空间中的内容覆盖至保持空间中                           |
| ---- | ------------------------------------------------------------ |
| H    | 把模式空间中的内容追加至保持空间中                           |
| g    | 从保持空间取出数据覆盖至模式空间                             |
| G    | 从保持空间取出内容追加至模式空间                             |
| x    | 把模式空间中的内容与保持空间中的内容进行互换                 |
| n    | 读取匹配到的行的下一行覆盖至模式空间                         |
| N    | 读取匹配到的行的下一行追加至模式空间                         |
| d    | 删除模式空间中的行                                           |
| D    | 删除当前模式空间开端至\n 的内容（不再传至标准输出），放弃之后的命令，但是对剩余模式空间重新执行sed |

```shell
sed '1!G;h;$!d' num.txt  # 按行倒序输出文件内容。执行过程：依次读取一行至模式空间中，对其执行G（第一行除外）-h-d（最后一行除外）命令，借助保持空间（模式空间的缓存）达到处理效果。
seq 9 | sed -n "n;p"  # 打印2 4 6 8。执行过程：读取第一行内容1，执行n命令，取下一行内容至模式空间，此时模式空间内容为2，执行p命令，打印模式空间内容2；再继续读取一行内容3，执行n命令，取下一行内容至模式空间，此时模式空间内容为4，执行p命令，打印模式空间内容4；依此类推...
```

------



# awk

### 简介

​          awk是一种**编程语言**，以每行记录中的字段为单位对文本进行处理。用于在linux/unix下对文本和数据进行处理，数据可以来自标准输入(stdin)、一个或多个文件，或其它命令的输出。它**支持用户自定义函数**和动态正则表达式等先进功能，是linux/unix下的一个强大编程工具。它**可在命令行中使用（一般用于有规律、有格式的文本），但更多是作为脚本来使用**。**awk有很多内建的功能**，比如数组、函数等，这是它和C语言的相同之处，灵活性是awk最大的优势。

### 内置常量：

```
$0            表示整个当前行
$1            每行第一个字段
NF            字段数量变量
NR            每行的记录号，多文件记录递增
FNR           与NR类似，不过多文件记录不递增，每个文件都从1开始
\t            制表符
\n            换行符
FS            定义分隔符
RS            输入的记录分隔符， 默认为换行符(即文本是按一行一行输入)
 ~             匹配，与==相比不是精确比较
!~             不匹配，不精确比较
==             等于，必须全部相等，精确比较
!=             不等于，精确比较
&&　           逻辑与
||             逻辑或
+              匹配时表示1个或1个以上
/[0-9][0-9]+/  两个或两个以上数字
/[0-9][0-9]*/  一个或一个以上数字
FILENAME       文件名
OFS            输出字段分隔符， 默认也是空格，可以改为制表符等
ORS            输出的记录分隔符，默认为换行符,即处理结果也是一行一行输出到屏幕
-F'[:#/]'      定义三个分隔符，等同于-v FS='[:#/]'
```

### 命令行用法：

```shell
awk -F\| '{printf "%d: %s-%s-%s\n", NF,$1,$2,$3}' a.txt  # 格式化输出每行文件被|分隔后的字段数和前3个字段。注意，“|”需要转义，否则报错，因为“|”默认为linux下的管道符。

awk -v FS=':' -v OFS='---' '{print $1,$2}' awkdemo  # "-v FS=':'"等同于"-F:"；-v OFS指定输出分隔符; print 输出格式简单、固定。

awk -F: '{if($3>10 && $3<1000) print $1,$3}' /etc/passwd  # if-else语句
```

### 数组：

（1）可使用任意字符串；字符串要使用双引号括起来

（2）如果某数组元素事先不存在，在引用时，awk 会自动创建此元素，并将其值初始化为“空串”

（3）若要判断数组中是否存在某元素，要使用“index in array”格式进行**遍历**

（4）若要**遍历数组中的每个元素**，要使用for 循环**：for(var in array)** {for-body}

```shell
awk '!arr[$0]++' a.txt  # 打印去重。执行过程：数组以每行内容为下标，初次读到这一行内容，这一行对应的数组元素值为空，打印这行内容，“!”取反数组元素变为1，下次读取到这一行内容时，"!"取反数组元素又变成0，就不打印了

awk '{arr[$0]++; {print $0,arr[$0]}}' a.txt   # 打印整行内容及出现次数
```

