# 目录  
- [优化原则](#优化原则)  
- [工具](#工具)  
- [关键点](#关键点)  
- [实操](#实操)
- [应用](#应用)

# 优化原则  
1. 不过早优化，当性能成为关键时再优化  
2. 先优化架构、框架、流程、系统配置、设置编译器优化相关参数这些宏观上的东西        
3. 找出性能瓶颈，对热点代码进行优化  
4. 可考虑空间换时间

# 工具 
详见【工具】目录
* perf   

* VTune  
interl程序性能工具。   
https://software.intel.com/en-us/vtune-amplifier-help-amplxe-cl-command-syntax  

# 关键点  
* 内存(包括对齐、cache）
* 分支预测

# 实操  
此处为一般性优化操作。
## 设计  
* 优先多核，然后多线程
* 数据本地化、无锁化  
## 变量 
* 尽量少用全局变量，可先赋值给局部变量再使用  
* 尽量使用const、static（本地化）变量 
* 少用数组，换成指针  
* 结构体要对齐，使用\_\_attribute__(\_\_aligned__(a)))，根据CPU设置，一般a为64，可通过命令查看，cat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size
## 函数及逻辑
* 函数不需要返回值时，用void减少栈操作  
* 尽量消除条件分支判断  
* if、switch 分支中，按出现可能性由高到低排放  
* 多语句宏、想用goto语句时，用do...while(0)  
* 尽量用static、inline函数，函数参数也尽量用const
* 必要时，使用预取指令预取数据
* 尽量用位运算
## 编译相关    
* -O3优化  
* 没有开启-O编译优化，任何函数是不会被内联的，使用–Winline，让gcc对标志成inline但不能被展开的函数给出警告信息，例如，使用了可变函数、递归  
* 尽量作函数声明，此时可手动添加各种属性\_\_attribute\_\_以使编译器作优化  
* **没有使用函数返回值将会在编译时产生警告**：\_\_attribute__((warn_unused_result))
* 函数尽量使用const、static（本地化）、inline(用\_\_attribute\_\_((always_inline))强制内联)及其组合来修饰函数  
* 函数返回值**仅仅依赖于输入参数**时（不涉及staic变量、全局变量、指针等），用\_\_attribute__((const))修饰函数，编译器会使得相同的输入只会计算一次。比如求一个数的平方。 \_\_attribute\_\_((pure))与const属性用处类似，没有const那么严格，比如 int hash (char \*) \_\_attribute\_\_ ((pure));。   
* 编译器对函数参数进行非空检查（只能检查明确的NULL传参，不能检查p=NULL，传入p的情况）：\_\_attribute__((nonnull))，也可指定检查第几个参数（参数序号从1开始）\_\_attribute__((nonnull(2)))
* 编译器会将热点函数集中放在txe section某处，以改善本地化：\_\_attribute__((hot))  
* if条件出现概率可预测时，**尽量用likely、unlikely**，否则不用  

# 应用  
## DPDK应用程序优化  
* 选型：dpdk有两种模式，对比发现其中一种的性能比另一种强  
* dpdk内部实现了内存相关的操作函数，它们更高效，比如rte_malloc/rte_free/rte_memcpy/rte_strcpy，尽量使用这些函数。类似地，还有rte_ring/rte_mempool/rte_hash 等。
* 每个核单独使用的变量尽量用 RTE_PER_LCORE 宏修饰
