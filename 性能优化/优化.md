# 目录  
- [优化原则](#优化原则)  
- [工具](#工具)  
- [关键点](#关键点)  
- [实操](#实操)
- [应用](#应用)

# 优化原则  
1. 不过早优化，当性能成为关键时再优化  
2. 先优化架构、框架、流程、系统配置、设置编译器优化相关参数这些宏观上的东西        
3. 找出性能瓶颈，对热点代码进行优化  
4. 可考虑空间换时间

# 工具 
详见【工具】目录
* perf   

* VTune  
interl程序性能工具。   
https://software.intel.com/en-us/vtune-amplifier-help-amplxe-cl-command-syntax  

# 关键点  
* 内存(包括对齐、cache）
* 分支预测

# 实操  
此处为一般性优化操作。
## 设计  
* 优先多核，然后多线程
* 数据本地化、无锁化  
## 变量 
* 不同类型声明顺序（-）
* 同时声明多个同类型的变量 （-）  
* 尽量少用全局变量，可先赋值给局部变量再使用  
* 尽量使用const、static（本地化）  
* 少用数组，换成指针  
* 结构体要对齐，使用\_\_attribute__(\_\_aligned__(a)))，根据CPU设置，一般a为64，可通过命令查看，cat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size
## 函数及逻辑
* 函数不需要返回值时，用void减少栈操作  
* 尽量消除条件分支判断  
* if、switch 分支中，按出现可能性由高到低排放  
* 多语句宏、想用goto语句时，用do...while(0)  
* 尽量用位运算替换乘除、求模。加法比乘法快  
## 编译相关    
* -O3优化  
* 定义函数原型，便于编译器优化  
* 函数尽量使用const、static（本地化）、inline(用\_\_attribute\_\_((always_inline))强制内联)及其组合来修饰函数  
* 函数返回值**仅仅依赖于输入参数**时（不涉及staic变量、全局变量、指针等），用\_\_attribute__((const))修饰函数，编译器会使得相同的输入只会计算一次    
* 编译器对函数参数进行非空检查：\_\_attribute__((nonnull)
* if条件出现概率可预测时，用likely、unlikely，否则不用  

# 应用  
## DPDK应用程序优化  
* 选型：dpdk有两种模式，对比发现其中一种的性能比另一种强  
* dpdk内部实现了内存相关的操作函数，它们更高效，比如rte_malloc/rte_free/rte_memcpy/rte_strcpy，尽量使用这些函数。类似地，还有rte_ring/rte_mempool/rte_hash 等。
* 每个核单独使用的变量尽量用 RTE_PER_LCORE 宏修饰
