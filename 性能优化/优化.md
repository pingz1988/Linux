# 目录  
- [优化原则](#优化原则)  
- [工具](#工具)  
- [关键点](#关键点)  
- [实操](#实操)
- [应用](#应用)

# 优化原则  
1. 不过早优化，当性能成为关键时再优化  
2. 先优化架构、框架、流程、系统配置、设置编译器优化相关参数这些宏观上的东西        
3. 找出性能瓶颈，对热点代码进行优化  
4. 可考虑空间换时间

# 工具 
* perf   
https://github.com/pingz1988/Linux/blob/master/%E5%B7%A5%E5%85%B7/perf.md

Intel平台工具：
* VTune     
https://software.intel.com/en-us/vtune-amplifier-help-amplxe-cl-command-syntax  
* Intel Thread Checker  
* Intel Thread Profiler  

# 关键点  
* 内存(包括对齐、cache、内存分配等）
* 分支预测

# 实操  
以下为一般性优化操作

## 设计  
* 优先多核，然后多线程
* 数据本地化、无锁化  

## 变量 
* 尽可能用无符号变量
* 尽量少用全局变量，可先赋值给局部变量再使用  
* 尽量使用const、static（本地化）变量 
* 少用数组，换成指针。用restrict修饰的指针，表明指针所指向的内存只能由该指针来修改，而不能由其它变量或指针来修改，避免指针别名问题，这样做可以让编译器优化代码。 memcpy(void * restrict dest, void * restrict src, size_t n)使用了restrict关键字，不让内存重叠操作。
* 结构体要对齐，一般以cached line 64字节对齐  
* 线程中的本地全局变量让它对齐_declspec(align(64)) int thread_local_val，以避免伪共享（false sharing）引发的cache line调度

## 函数及逻辑
* 函数不需要返回值时，用void减少函数栈操作  
* 尽量减少函数间的调用层数，以减小函数栈调用开销
* 尽量消除条件分支判断  
* if、switch 分支中，按出现可能性由高到低排放  
* 多语句宏、想用goto语句时，用do...while(0)  
* 尽量用static、inline函数（内联函数中要注意提高分支预测率、减少函数调用），函数参数也尽量用const
* 尽量用位运算  

## 循环  
* 循环展开

## 分支预测
* 排列代码使得分支预测符合静态分支预测结果：静态分支预测**if(condition)中的前向条件为不采取**，可以把逻辑改成**if(!condition)**；静态分支预测while(condition)/for(condition)中的后向条件为采取
* 尽量减少甚至消除分支（运用上述的循环展开、排列代码方式），尤其在主逻辑中
* if条件出现的概率可预测时，**使用likely、unlikely**，否则不用  

## 编译相关  
* 变量对齐  
\_\_attribute\_\_(aligned(N)) 属性指定变量以N字节对齐；\_\_attribute\_\_(packed)属性指定变量以最小字节数对齐，位域变量以位对齐，其它变量则以一字节对齐
* -O3优化  
* 没有开启-O编译优化，任何函数是不会被内联的，使用–Winline，让gcc对标志成inline但不能被展开的函数给出警告信息，例如，使用了可变函数、递归  
* 尽量作函数声明，此时可手动添加各种属性\_\_attribute\_\_以使编译器作优化  
* **没有使用函数返回值将会在编译时产生警告**：\_\_attribute__((warn_unused_result))
* 函数尽量使用const、static（本地化）、inline(用\_\_attribute\_\_((always_inline))强制内联)及其组合来修饰函数  
* 函数返回值**仅仅依赖于输入参数**时（不涉及staic变量、全局变量、指针等），用\_\_attribute__((const))修饰函数，编译器会使得相同的输入只会计算一次。比如求一个数的平方。 pure与const属性用处类似，没有const那么严格，比如 int hash (char \*) \_\_attribute\_\_ ((pure))   
* 编译器对函数参数进行非空检查（只能检查明确的NULL传参，不能检查p=NULL，传入p的情况）：\_\_attribute__((nonnull))，也可指定检查第几个参数（参数序号从1开始）\_\_attribute__((nonnull(2)))
* 函数使用hot属性\_\_attribute__((hot))会将热点函数集中放在txt section某处，以改善本地化；函数使用cold属性也会把函数集中放在txt section某处，这些函数不大可能执行，在分支预测时有用，比如perror函数。
* \_\_attribute__(section_name) 修饰函数或变量，将其放入以section_name命名的段中，以提高代码和数据的本地化（**还需理解及验证**）  

## 并行化
Amdahl定律：增加处理器数、计算负载分布到更多处理器上；串行计算程序的加速，取决于程序代码可并行化的比例。  
编译器对满足条件的代码进行并行化处理，以优化执行。  
* 循环可并行的3个条件    
  1、进入循环之前，循环次数是确定的（while循环就不符合这个条件）  
  2、循环中，不能跳入或跳出循环  
  3、各次循环之间的数据是独立没有依赖的（计算结果与执行顺序无关）  
  可以手动告诉编译器对循环并行化，在循环前加一行\#pragma parallel   
  ```c
  void add (int k, float *a, float *b)
  {
    #pragma parallel
      for (int i = 1; i < 10000; i++)
        a[i] = a[i+k] + b[i];
  }
  ```
  gcc命令行参数-par_report3打印哪些循环可以并行化、哪些循环不能并行化的详细信息  
* 指针或数组别名  
  指针或数组别名是编译器判断代码是否可安全并行的阻碍。restrict关键字修饰指针或数组变量，告诉编译器变量所指的内存只能由这个变量来修改，有利于编译器并行化处理    
