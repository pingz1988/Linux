## 方法  
从代码逻辑流程出发，关注内存操作（申请、释放、拷贝），而不是像“无头苍蝇”样的去分析报错的逻辑内存地址  

## 问题 

* 函数返回值  
void型函数，返回了值；非void型函数，没有返回值。函数分支多的时候容易有这个问题

* 使用未初始化内存  
malloc之后，没有memset；结构体内的指针不分配内存空间就使用

* 使用空指针    
使用指针前没有作非空判断，可能由于释放了指针或都指针本身为空，而访问了空指针

* 踩内存   
内存读写越界（溢出）：数组元素个数只有N，却访问大于等于N位置的数组元素，调用memcpy、strcpy函数容易出现

* 动态内存管理错误    
malloc、calloc、new不判断返回值，就直接使用

* 野指针     
释放内存不置空

* 内存泄漏  
分配内存而没有释放

* 句柄泄漏  
使用文件、socket等句柄后，没有关闭


## 辅助方式
* 设置MALLOC_CHECK环境变量  
export MALLOC_CHECK=2  // 启用malloc/free检查。2表示发现此类问题时，让程序直接coredump

* valgrid    
效果待确认，不好直接定位问题所在  

* AddressSanitizer(ASan)    
可定位malloc/free内存泄漏方面问题。gcc自带，4.8以上版本都可以使用，不止可以检测内存泄漏，它其实是一个内存错误检测工具。  

* Electric fence    
可定位野指针、内存溢出方面的问题
